# Generators generate a stream of random tetrominoes.
# A generator consists of:
#     - random source (source of randomness)
#     - packer
#     - unpacker
# 
# The random source generates random integers between 0 and 6.
# These integers represent the Tetromino types I, J, L, O, S, T, and Z.
# The random source outputs the integers to the packer
# 
# The packer packs these integers into bags of n tetrominoes obeying certain
# bagging rules, e.g. packing into bags of 7 unique integers. The packer 
# yields these bags to the unpacker.
# 
# The unpacker unpacks these bags and offers the preview of x next
# tetrominoes, e.g. 3 next tetrominoes.
# The unpacker yields the first next tetromino to the program.


import generators.python9001.python9001 as gen
import generators.ones.ones as ones
import generators.primus.primus as primus
from collections import deque
from typing import Callable
import random
import logging
import logging.config
import logging_conf

# Setup logging
logging.config.dictConfig(logging_conf.dict_config)
logger = logging.getLogger(__name__)


class Random_Source():
    """
    This is a wrapper for a python-like random integer function.
    """
    def __init__(self, seed=None, set_seed=None, function=None, args=(), kwargs={}):
        self.seed = seed
        self.set_seed = set_seed
        # set the seed
        if self.set_seed is not None:
            self.set_seed(self.seed)
        self.function = function
        self.args = args
        self.kwargs = kwargs
    def __next__(self):
        random_number = self.function(*self.args, **self.kwargs)
        logger.debug(f"Random_Source returning {random_number}")
        return random_number


def one_I_in_7(rs: Random_Source):
    """
       A Packer-type function which takes random number from the generator
       and packs them into a deque of seven non-repeating numbers.
       This practically emulates a random.shuffle of [0, 1, 2, 3, 4, 5, 6]
    """
    maxlen = 7
    bag = deque([], maxlen)
    logger.debug("filling the bag")
    while len(bag) < maxlen -1:
        to_append = next(rs)
        if to_append not in bag:
            logger.debug(f"{to_append} is not in the bag")
            bag.append(to_append)
            logger.debug(f"added {to_append} to the bag")
        else:
            logger.debug(f"discarding {to_append}, it is already in the bag")
    logger.debug("bag is missing one more number.")
    bag_has = set(bag)
    logger.debug(f"Currently we have: {bag_has}")
    bag_hasnt = set(range(maxlen))
    bag_hasnt.difference_update(bag_has)
    logger.debug(f"but is missing {bag_hasnt}, appending {bag_hasnt}")
    bag.append(bag_hasnt.pop())
    yield bag


def no_rules(rs: Random_Source):
    """
       An indifferent packer which relays any number it gets from the generator
       without imposing any own rules.
    """
    number = next(rs)
    logger.debug(f"got {number}, yielding {number}")
    yield deque([number], 1)


def seven_ones(rs: Random_Source):
    """
       A packer which only packs ones into the bag and ignores all other numbers
       generated by the generator. Written for debugging purposes. May be deleted.
    """
    maxlen = 7
    result = deque([], maxlen)
    while len(result) < result.maxlen:
        to_check = next(rs)
        if to_check == 1:
            logger.debug(f"appending {to_check}")
            result.append(to_check)
        else:
            logger.debug(f"discarding {to_check}")
    logger.debug(f"returning full bag: {result}")
    yield result


packer_dict = {"one_I_in_7": one_I_in_7,
               "no_rules": no_rules,
               "seven_ones": seven_ones,
               }


class Unpacker():
    def __init__(self, packer: Callable[[Random_Source], deque], rs: Random_Source) -> None:
        self.packer = packer
        self.rs = rs
        self.got_bag = deque([], 0)
        logger.debug(f"initialized unpacker with {self.got_bag}")
        self.next_queue = deque([], 7)
    def request_next(self) -> None:
        """
           Requests next number from the random source and appends it
           to the next_queue
        """
        try:
            logger.debug(f"Unpacker requesting next piece from current bag: {self.got_bag}")
            result = self.got_bag.popleft()
        except IndexError:
            logger.debug("Unpacker requesting new bag")
            self.got_bag = next(self.packer(self.rs))
            logger.debug(f"got new bag: {self.got_bag}, popping left...")
            result = self.got_bag.popleft()
        self.next_queue.append(result)
        logger.debug(f"Appended {result} to the next_queue: {self.next_queue}")
    def spawn_next(self):
        try:
            logger.debug("Unpacker trying to spawn next piece...")
            result = self.next_queue.popleft()
            logger.debug(f"Unpacker will spawn {result} soon...")
            self.request_next()
        except IndexError:
            logger.debug("The next_queue seems to be empty. Requesting next piece...")
            self.request_next()
            result = self.next_queue.popleft()
            self.request_next()
        logger.debug(f"Unpacker spawning {result}")
        return result
    def preview_next(self, number: int) -> None:
        logger.debug("Entered preview")
        for i in range(number):
            logger.debug(f"Trying to preview next {number} pieces")
            try:
                logger.debug(f"See what {self.next_queue} has at index {i}")
                yield self.next_queue[i]
            except IndexError:
                logger.debug(f"Unpacker's Next Queue is not long enough")
                for _ in range(number - len(self.next_queue)):
                    self.request_next()
                logger.debug(f"Unpacker's Next Queue is long enough to yield {self.next_queue[i]}")
                yield self.next_queue[i]


rs_dict = {"python9001": Random_Source(function=gen.generate),
           "randint06": Random_Source(seed=9001, set_seed=random.seed, function=random.randint, args=(0, 6)),
           "ones": Random_Source(function=ones.generate),
           "primus": Random_Source(function=primus.generate),
           }


if __name__ == "__main__":
    r = Unpacker(packer_dict["no_rules"], rs_dict["randint06"])
    logger.debug(f"Preview next 7: {tuple(r.preview_next(7))}")
    logger.debug(f"Spawning: {r.spawn_next()}")
    logger.debug(f"Preview next 7: {tuple(r.preview_next(7))}")
